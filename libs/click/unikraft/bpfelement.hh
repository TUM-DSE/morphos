#ifndef CLICK_BPFELEMENT_HH
#define CLICK_BPFELEMENT_HH

#include <click/config.h>
#include <click/deque.hh>
#include <click/element.hh>
#include <click/error.hh>
#include <click/task.hh>
#include <uk/rwlock.h>
#include <bpf_helpers.hh>
#include <ubpf.h>

CLICK_DECLS

class BPFElement : public Element {
public:

    bool can_live_reconfigure() const override { return true; }

    int configure(Vector <String> &conf, ErrorHandler *errh) override CLICK_COLD;

    uint64_t bpfelement_id() const { return _bpfelement_id; }

protected:

    struct uk_rwlock _lock = UK_RWLOCK_INITIALIZER(_lock, 0);
    struct ubpf_vm *_ubpf_vm = nullptr;

    virtual void register_additional_bpf_helpers(void) { }

    uint32_t exec(int port, Packet *p);

private:

    uint64_t _bpfelement_id;
    bool _jit;
    bool _dump_jit;
    String _bpf_file;
    String _signature_file;

    struct bpf_map_ctx *_bpf_map_ctx;
    ubpf_jit_ex_fn _ubpf_jit_ex_fn;
    void* _ubpf_ebpf_stack; // stack verified by eBPF verifier
    size_t _ubpf_ebpf_stack_len;
    void* _ubpf_jit_stack; // additional stack used by VM generated by JIT (stack actually starts at _ubpf_jit_stack+__PAGE_SIZE-sizeof(struct bpfelement_md)-1)
    size_t _ubpf_jit_stack_len;
    void* _ubpf_jit_stack_protector; // additional stack used by VM generated by JIT
    size_t _ubpf_jit_stack_protector_len;

    int _pkey_stack;

    void init_ubpf_vm();
    int check_bpf_verification_signature(ErrorHandler *errh);
    int allocate_jit_stack();

    CLICK_COLD;
};

typedef struct {
    void* data;
    void* data_end;
    uint32_t port;
} bpfelement_md;

CLICK_ENDDECLS
#endif
